树：

#938    （Range_Sum_of_BST）                   二叉搜索树的范围和            给定二叉搜索树的根结点root，返回 L和R（含）之间的所有结点的值的和
#617     (Merge_Two_Binary_Trees)             合并二叉树
#226    （Invert_Binary_Tree）                 翻转二叉树                   翻转一棵二叉树
#104     (Maximum_Depth_of_Binary_Tree)       二叉树的最大深度              给定一个二叉树，找出其最大深度。最大深度为从根节点到最远叶子节点的最长路径上的节点数量。
#111     (Minimum_Depth_of_Binary_Tree)       二叉树的最小深度              给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
#559     (Maximum_Depth_of_N_Tree)            N叉树的最大深度
#700     (Search_in_a_Binary_Search_Tree)     二叉搜索树中的搜索            在BST中找到节点值等于给定值的节点。
#144     (Binary_Tree_Preorder_Traversal)     二叉树的前序遍历
#94      (Binary_Tree_Inorder_Traversal)      二叉树的中序遍历
#145     (Binary_Tree_Postorder_Traversal)    二叉树的后序遍历
#102     (Binary_Tree_Level_Order_Traversal)  二叉树的层次遍历              自上向下的层次遍历
#107     (Binary_Tree_Level_Order_Traversal)  二叉树的层次遍历             自底向上的层次遍历
#589     (N_Tree_Preorder_Traversal)          N叉树的前序遍历
#590     (N_Tree_Postorder_Traversal)         N叉树的后序遍历
#108     (Convert_Sorted_Array_to_BST)        将有序数组转换为二叉搜索树     将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树
#965     (Univalued_Binary_Tree)              单值二叉树                   判断单值二叉树，如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树
#429     (N_Tree_Level_Order_Traversal)       N叉树的层序遍历               给定一个 N 叉树，返回其节点值的层序遍历
#669     (Trim_a_Binary_Search_Tree)          修剪二叉搜索树                给定BST，最小和最大边界LR。修剪二叉搜索树，使得所有节点的值在[L, R]中
#637     (Average_of_Levels_in_Binary_Tree)   二叉树的层平均值              给定一个非空二叉树, 返回一个由每层节点平均值组成的数组
#235     (Lowest_Common_Ancestor_of_a_BST)    二叉搜索树的最近公共祖先       给定一个BST, 找到该树中两个指定节点的最近公共祖先。(一个节点也可以是它自己的祖先)
#538     (Convert_BST_to_Greater_Tree)        把二叉搜索树转换为累加树       转换一个BST成为累加树，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。
#112     (Path_Sum)                           路径总和                     判断该树中是否存在根节点到叶子节点的路径上所有节点值相加等于目标和。
#113     (Path_Sum)                           路径总和                     找到所有从根节点到叶子节点路径总和等于给定目标和的路径。
#437     (Path_Sum)                           路径总和                     找出路径和等于给定数值的路径总数。（不局限于根节点和叶子节点）
#101    （Symmetric_Tree）                    对称二叉树                    给定一个二叉树，检查它是否是镜像对称的。
#543     (Diameter_of_Binary_Tree)           二叉树的直径                  计算一个二叉树的直径。直径是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。
#872     (Leaf_Similar_Trees)                叶子相似的树                  一颗二叉树上所有叶子的值按从左到右的顺序排列形成一个叶值序列,若两颗二叉树的叶值序列相同则是叶相似的
#897     (Increasing_Order_Search_Tree)      递增顺序查找树                给定一个树，按中序遍历重新排列树，使树中最左边的结点现在是树的根，且每个结点只有一个右子结点。
#257     (Binary_Tree_Paths)                 二叉树的所有路径              给定一个二叉树，返回所有从根节点到叶子节点的路径
#100     (Same_Tree)                         相同的树                     给定两个二叉树，编写一个函数来检验它们是否相同
#530     (Minimum_Absolute_Difference_in_BST)二叉搜索树的最小绝对差          给定一个所有节点为非负值的二叉搜索树，求树中任意两节点的差的绝对值的最小值
#653     (Two_Sum_of_BST)                    两数之和 IV - 输入 BST        给定一个BST和一个目标，如果BST中存在两个元素且它们的和等于给定的目标结果，则返回true。
#783     (Minimum_Distance_Between_BST_Nodes)二叉搜索树结点最小距离          给定一个二叉搜索树的根结点 root, 返回树中任意两节点的差的最小值
#404     (Sum_of_Left_Leaves)                左叶子之和                    计算给定二叉树的所有左叶子之和。
#606     (Construct_String_from_Binary_Tree)根据二叉树创建字符串            采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。空节点则用一对空括号 "()" 表示
#563     (Binary_Tree_Tilt)                 二叉树的坡度                   给定一个二叉树，计算整个树的坡度。一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。整个树的坡度就是其所有节点的坡度之和
#110     (Balanced_Binary_Tree)             平衡二叉树                     给定一个二叉树，判断它是否是高度平衡的二叉树。
#270     (Closest_Binary_Search_Tree_Value) 最接近的二叉搜索树值            给定一个不为空的BST和一个目标值target，请在该BST中找到最接近目标值target的数值。
#993     (Cousins_in_Binary_Tree)            二叉树的堂兄弟节点             如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。
#671    （Second_Minimum_Node_In_a_Binary_Tree）二叉树中第二小的节点        给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。
#501     (Find_Mode_in_Binary_Tree)          二叉搜索树中的众数             给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
#102     (Sum_of_Root_To_Leaf_Binary_Numbers)从根到叶的二进制数之和         给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。
#572     (Subtree_of_Another_Tree)           另一个树的子树                给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
#687     (Longest_Univalue_Path)              最长同值路径                 给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。这条路径可以经过也可以不经过根节点。注意：两个节点之间的路径长度由它们之间的边数表示。
